import { useEffect, useState } from "react";
import { Recommendation, SortOrder } from "./RecommendAnnotationModal";
import { IDBPDatabase } from "idb";
import { MyDB } from "../../App";

interface SortConfig {
  field: keyof Recommendation | null;
  order: SortOrder;
}

export interface RecommendationTableProps {
  db: IDBPDatabase<MyDB> | null | undefined;
  fileName: string;
  isConverted: boolean;
  recommender: any;
  recommendations: Recommendation[];
  selectedRecommendationsInput: Record<string, boolean>;
  onClose: ((fileName: string) => void) | null;
}

export const RecommendationTable: React.FC<RecommendationTableProps> = ({db, fileName, isConverted, recommender, recommendations, selectedRecommendationsInput, onClose}) => {

  const [sortConfig, setSortConfig] = useState<SortConfig>({
    field: null,
    order: SortOrder.ASC,
  });
  const [selectedRecommendations, setSelectedRecommendations] = useState<
    Record<string, boolean>
  >(selectedRecommendationsInput);

  /**
   * Generates a unique key for a recommendation using its ID and annotation.
   * This ensures selections remain stable even when sorting or filtering the list.
   *
   * @param rec - The recommendation object.
   * @returns A string key in the format "id-annotation".
   */
  const getRecommendationKey = (rec: Recommendation) =>
    `${rec.id}-${rec.annotation}`;

  /**
 * Updates the sorting configuration based on the selected field.
 * Toggles between ascending and descending order if the same field is clicked.
 *
 * @param field - The recommendation field to sort by.
 */
  const handleSort = (field: keyof Recommendation) => {
    setSortConfig((prev) => ({
      field,
      order:
        prev.field === field && prev.order === SortOrder.ASC
          ? SortOrder.DESC
          : SortOrder.ASC,
    }));
  };

  /**
 * Sort recommendations based on the sort config.
 */
  const sortedRecommendations =
    sortConfig.field !== null
      ? [...recommendations].sort((a, b) => {
        const field = sortConfig.field as keyof typeof a;
        const valueA = a[field];
        const valueB = b[field];
        if (typeof valueA === "number" && typeof valueB === "number") {
          return sortConfig.order === SortOrder.ASC
            ? valueA - valueB
            : valueB - valueA;
        } else if (typeof valueA === "string" && typeof valueB === "string") {
          return sortConfig.order === SortOrder.ASC
            ? valueA.localeCompare(valueB)
            : valueB.localeCompare(valueA);
        }
        return 0;
      })
      : recommendations;

  /**
   * Updates the file with selected annotations by generating an SBML document.
   * Converts it to Antimony if needed.
   */
  const handleUpdateAnnotations = async () => {
    try {
      if (recommender) {
        const selected = recommendations.filter(
          (rec) => selectedRecommendations[getRecommendationKey(rec)]
        );

        const updatedSBMLString = recommender.getSBMLDocument({
          sbmlDocument: recommender.sbmlDocument,
          chosen: selected,
          autoFeedback: true,
        });

        // Update AWE
        let updatedContent;
        if (isConverted) {
          // Convert to Antimony if needed
          if (window.convertSBMLToAntimony) {
            updatedContent = await window.convertSBMLToAntimony(
              updatedSBMLString
            );
            window.antimonyString = updatedContent;
          } else {
            console.error(
              "convertSBMLToAntimony function not found in the global scope."
            );
            return;
          }
        } else {
          updatedContent = updatedSBMLString;
          window.sbmlString = updatedContent;
        }

        //setFileContent(updatedContent);

        window.localStorage.setItem("current_file", updatedContent);
        if (db) {
          const updatedFile = { name: fileName, content: updatedContent };
          await db.put("files", updatedFile);
          // const updatedFiles = await db.getAll("files");
          // const updatedDatabase = await openDB<MyDB>("antimony_editor_db");
          // setUploadedFiles(updatedFiles);
          // setDb(updatedDatabase);
        }
      }
    } catch (error) {
      console.error("Unable to update annotations:", error);
    } finally {
      if (onClose) {
        onClose(fileName);
      } else {
        console.error("Recommendation Table cannot be closed, improperly initialized")
      }
    }
  };

  /**
   * Toggles the selection of a recommendation by its recommendation key generated by getRecommendationKey.
   * If the recommendation is already selected, it will be deselected, and vice versa.
   */
  const handleSelect = (key: string) => {
    setSelectedRecommendations((prev) => ({
      ...prev,
      [key]: !prev[key],
    }));
  };

  useEffect(() => {
    console.log("Rendering")
  }, [])

  return (
    <>
      <div className="annot-grid">
        <div className="annot-grid-header-container">
          <div
            className="annot-grid-header sortable-header"
            onClick={() => handleSort("type")}
          >
            <div>Type</div>
            <div>
              {sortConfig.field === "type"
                ? sortConfig.order === SortOrder.ASC
                  ? "↑"
                  : "↓"
                : "↕"}
            </div>
          </div>
          <div className="annot-grid-header">ID</div>
          <div className="annot-grid-header">Display Name</div>
          <div className="annot-grid-header">Annotation</div>
          <div className="annot-grid-header">Annotation Label</div>
          <div
            className="annot-grid-header sortable-header"
            onClick={() => handleSort("matchScore")}
          >
            <div>Match Score</div>
            <div>
              {sortConfig.field === "matchScore"
                ? sortConfig.order === SortOrder.ASC
                  ? "↑"
                  : "↓"
                : "↕"}
            </div>
          </div>
          <div className="annot-grid-header">Selected Annotation</div>
        </div>

        {sortedRecommendations.map((rec) => {
          const key = getRecommendationKey(rec);
          return (
            <div
              className={`annot-grid-row ${rec.isLowMatch && "low-match"
                }`}
              key={key}
            >
              <div className="annot-grid-item">{rec.type}</div>
              <div className="annot-grid-item">{rec.id}</div>
              <div className="annot-grid-item">{rec.displayName}</div>
              <div className="annot-grid-item">{rec.annotation}</div>
              <div className="annot-grid-item">{rec.annotationLabel}</div>
              <div className="annot-grid-item">{rec.matchScore}</div>
              <div className="annot-grid-item">
                <input
                  type="checkbox"
                  checked={selectedRecommendations[key] || false}
                  onChange={() => handleSelect(key)}
                />
              </div>
            </div>
          );
        })}
      </div>
      <div
        className="annot-recommend-button"
        onClick={handleUpdateAnnotations}
      >
        Update annotations
      </div>
    </>
  )
}

export default RecommendationTable;